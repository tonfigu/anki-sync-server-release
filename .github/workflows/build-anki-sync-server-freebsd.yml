# 文件名: .github/workflows/build-anki-sync-server-freebsd.yml
name: Manually Build Anki Sync Server (FreeBSD) # 可以稍微改下名字，强调手动

# 触发器：仅允许手动触发
on:
  workflow_dispatch:
    inputs:
      anki_version:
        description: '要构建和发布的 Anki 标签 (例如: 24.06.1)' # Anki 标签是纯数字格式
        required: true # 手动触发时必须提供版本号
        default: '24.06.1' # 提供一个最新的默认值示例

jobs:
  release:
    name: Build and Release Anki Sync Server on FreeBSD
    runs-on: ubuntu-latest # 使用 ubuntu runner 来启动 FreeBSD VM
    steps:
      # FreeBSD 虚拟机环境设置与构建步骤
      - name: Setup and Build on FreeBSD
        uses: vmactions/freebsd-vm@v1
        with:
          usesh: true # 使用 sh 而不是默认的 C shell
          release: 14.1 # 指定 FreeBSD 版本
          prepare: |
            pkg update -f
            # 安装构建依赖: git, rust 工具链, protobuf 编译器, C 编译器, GNU Make, 根证书
            pkg install -y git rust protobuf gcc gmake ca_root_nss
            echo "Installed dependencies: git, rust, protobuf, gcc, gmake, ca_root_nss"
          run: |
            set -e # 发生错误时立即退出

            echo "==================== 1. 确定 Anki 版本 ========================"
            # 因为是手动触发，版本号直接来自输入参数
            ANKI_TAG_INPUT="${{ github.event.inputs.anki_version }}"
            echo "Manual Input Tag: ${ANKI_TAG_INPUT}"

            # Anki 的 cargo install 需要 Git 仓库中存在的 *确切* 标签名。
            # 实际标签是纯数字格式 (如 24.06.1)。我们直接使用这个标签。
            ANKI_TAG="${ANKI_TAG_INPUT}"

            if [ -z "${ANKI_TAG}" ]; then
              echo "错误：必须提供 Anki 版本标签" >&2
              exit 1
            fi

            # 将标签写入环境变量供后续步骤使用
            echo "ANKI_TAG=${ANKI_TAG}" >> $GITHUB_ENV
            echo "使用的 Anki 标签: ${ANKI_TAG}"

            echo "==================== 2. 构建 Anki 同步服务器 ========================"
            INSTALL_ROOT="/tmp/anki-install"
            mkdir -p "${INSTALL_ROOT}"

            echo "正在运行 cargo install..."
            # 使用 cargo 从指定 Anki 标签构建 anki-sync-server
            cargo install --git https://github.com/ankitects/anki.git \
              --tag "${ANKI_TAG}" \
              --root "${INSTALL_ROOT}" \
              --locked \
              anki-sync-server

            echo "Cargo install 完成。"

            BUILT_BINARY="${INSTALL_ROOT}/bin/anki-sync-server"

            echo "==================== 3. 检查输出文件 ========================"
            if [ -f "${BUILT_BINARY}" ]; then
              echo "找到二进制文件: ${BUILT_BINARY}"
              ls -l "${BUILT_BINARY}"
              file "${BUILT_BINARY}" # 确认文件类型
            else
              echo "错误：构建失败，未找到二进制文件 ${BUILT_BINARY}" >&2
              exit 1
            fi

            echo "==================== 4. 准备输出归档文件 ========================"
            mkdir -p ../output
            cp "${BUILT_BINARY}" ../output/anki-sync-server
            cd ../output

            # 归档文件名包含版本和平台信息 (使用输入的纯数字标签)
            ARCHIVE_BASE_NAME="anki-sync-server-freebsd-amd64-${ANKI_TAG}"
            zip "${ARCHIVE_BASE_NAME}.zip" anki-sync-server
            tar -czf "${ARCHIVE_BASE_NAME}.tar.gz" anki-sync-server

            echo "已创建归档文件:"
            ls -l *.zip *.tar.gz

            # 将压缩包路径写入环境变量
            echo "ARCHIVE_ZIP=${ARCHIVE_BASE_NAME}.zip" >> $GITHUB_ENV
            echo "ARCHIVE_TAR_GZ=${ARCHIVE_BASE_NAME}.tar.gz" >> $GITHUB_ENV
            cd ..

            echo "==================== 5. 构建完成 ========================"

      # 上传构建产物到 GitHub Actions，方便下载或调试
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: anki-sync-server-freebsd-amd64-${{ env.ANKI_TAG }}
          path: |
            output/*.zip
            output/*.tar.gz

      # 创建 GitHub Release 并上传构建产物
      - name: Release
        # 注意：手动触发时，如果输入的版本标签 X 已存在 Release，
        # 'allowUpdates: true' 和 'replacesArtifacts: true' 会更新这个 Release。
        # 如果 'makeLatest: true'，这个 Release 会被标记为 'Latest'。
        uses: ncipollo/release-action@v1
        with:
          # Release 的标签使用手动输入的 Anki 版本标签
          tag: ${{ env.ANKI_TAG }}
          artifacts: "output/${{ env.ARCHIVE_ZIP }},output/${{ env.ARCHIVE_TAR_GZ }}"
          allowUpdates: true        # 允许更新已存在的 Release
          generateReleaseNotes: true # 自动生成 Release Notes
          makeLatest: true          # 将此 Release 标记为仓库的最新版本
          replacesArtifacts: true   # 如果 Artifacts 已存在，则替换它们
        env:
          # 需要仓库写入权限来创建/更新 Release
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
